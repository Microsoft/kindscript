diff --git a/docs/language.md b/docs/language.md
index 2a89cf1..22bf202 100644
--- a/docs/language.md
+++ b/docs/language.md
@@ -25,7 +25,8 @@ devices, either locally or in the cloud.
 In case of microcontrollers, PXT programs are 
 [compiled in the browser](https://www.touchdevelop.com/docs/touch-develop-in-208-bits)
 to ARM Thumb assembly, and then to machine code, resulting in a file
-which is then deployed to the microcontroller.
+which is then deployed to the microcontroller,
+usually [via USB mass-storage interface](https://makecode.com/blog/one-chip-to-flash-them-all).
 
 For browsers and node.js, PXT programs are compiled to 
 [continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style)
@@ -80,6 +81,7 @@ Things you may miss and we may implement:
 * binding with arrays or objects: `let [a, b] = ...; let { x, y } = ...`
 * `delete` statement (on object literals)
 * spread and reset operators (statically typed)
+* `typeof` expression
 
 For JS-only targets we may implement the following:
 
@@ -92,7 +94,6 @@ unlikely to miss it):
 * file-based modules (`import * from ...`, `module.exports` etc); we do support namespaces
 * `yield` expression and ``function*``
 * `await` expression and `async function`
-* `typeof` expression
 * tagged templates ``tag `text ${expression} more text` ``; regular templates are supported
 * `with` statement
 * `eval`
@@ -108,8 +109,13 @@ Note, that you can use all of these while implementing your runtime environment
 
 As such, it isn't really feasible to run a full JavaScript virtual machine
 in 3k of RAM, and thus PXT programs are statically compiled to native code to run efficiently.
-This causes some semantic differences:
 
+There are two compilation strategies available - the legacy strategy used by the current
+micro:bit target, and a tagged strategy used by the upcoming SAMD21 targets, as well as all
+the other targets going forward (possibly including new version of the micro:bit target).
+
+In the legacy strategy, there are some semantic differences with JavaScript,
+particularly:
 * numbers are 32 bit signed integers with wrap-around semantics; 
   in JavaScript they are 64 bit floating points
 * JavaScript doesn't have types, and therefore every value can be `undefined` or `null` 
@@ -117,29 +123,25 @@ This causes some semantic differences:
   in PXT `0`, `false`, `null`, and `undefined` all have the same underlying
   representation (32 zero bits) and thus will test as equal
 
+In the [tagged strategy](/js/float), numbers are either tagged 31-bit signed
+integers, or if they do not fit boxed doubles. Special constants like `false`, `null` and
+`undefined` are given special values and can be distinguished.
+We're aiming at full JavaScript compatibility here.
+
 ## Static compilation vs a dynamic VM
 
 PXT programs are compiled to native code. The native targets include ARM Thumb,
-and an unfinished AVR port.
+and an unfinished AVR port. The information below concerns the tagged compilation
+strategy.
 
-The execution strategy is more similar to C# or Java, rather than typical JavaScript engines,
-i.e., much closer to the metal.
-* integers, (upcoming) single precision floating point numbers, and booleans are all passed 
-  around unboxed
-* objects use reference counting
-* classes are laid out using static type information (like in C), so there is little memory overhead
-
-PXT also supports dynamic objects (also reference counted), which are essentially string-to-value
-mappings - these have much higher memory overhead, and would be typically the only thing available
-in a dynamic language.
-
-All of this lends itself to significant performance improvements over typical dynamic VM implementations:
+Compared to a typical dynamic JavaScript engine, PXT compiles code statically,
+giving rise to significant time and space performance improvements:
 * user programs are compiled directly to machine code, and are
   never in any byte-code form that needs to be interpreted; this results in execution
   10-20x faster than a typical JS interpreter
 * there is no RAM overhead for user-code - all code sits in flash; in a dynamic VM
   there are usually some data-structures representing code
-* due to lack of boxing and static class layout the memory consumption for objects
+* due to lack of boxing for small integers and static class layout the memory consumption for objects
   is around half the one you get in a dynamic VM (not counting
   the user-code structures mentioned above)
 * while there is some runtime support code in PXT, it's typically around 100KB smaller than
@@ -153,7 +155,7 @@ in particular for simple functions with numbers on input and output - there is
 no need for unboxing, checking types, or memory management.
 
 The main disadvantage of using static compilation is lack of dynamic features
-in the language, as explained above.
+in the language (think `eval`), as explained above.
 
 While it is possible to run a dynamic VM even on an nRF51-class device
 (256KB of flash, 16KB of RAM), it leaves little space for innovative features
@@ -161,8 +163,8 @@ on the software side, or more complex user programs and user-space (not C++) dri
 
 ## Smaller int types
 
-As noted above, when performing computations numbers are treated as signed 32 bit
-integers. However, when you store numbers in global variables or (soon) record fields you
+As noted above, when performing computations numbers are treated as doubles. 
+However, when you store numbers in global variables or (soon) record fields you
 can choose to use a smaller int type to save memory. Microcontrollers typically have very 
 little memory left, so these few bytes saved here and there (especially in commonly 
 used packages) do add up.
@@ -172,8 +174,8 @@ The supported types are:
 * `uint16` with range `0` to `65536`
 * `int8` with range `-128` to `127`
 * `int16` with range `-32768` to `32767`
-
-There is also `int32` type, but it's the same as `number`.
+* `int32` with range `-2147483648` to `2147483647`
+* `uint32` with range `0` to `4294967295`
 
 If you attempt to store a number exceeding the range of the small int type, only
 the lowest 8 or 16 bits will be stored. There is no clamping nor overflow exceptions.
@@ -182,4 +184,3 @@ the lowest 8 or 16 bits will be stored. There is no clamping nor overflow except
 
 * arrays of int types are currently not supported; you can use a `Buffer` instead
 * locals and parameters of int types are not supported
-* there is no `uint32` type - all numbers are treated as signed
