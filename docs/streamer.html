<html>

<head>
    <meta charset="UTF-8">
    <title>Microsoft MakeCode Streamer</title>
    <style>
        /*
  Use https://uifabricicons.azurewebsites.net/
*/
/*
  Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fabric-assets-license
*/
@font-face {
  font-family: 'FabricMDL2Icons';
  src: url('data:application/octet-stream;base64,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') format('truetype');
}

.ms-Icon {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  display: inline-block;
  font-family: 'FabricMDL2Icons';
  font-style: normal;
  font-weight: normal;
  speak: none;
}

.ms-Icon--PenWorkspace:before { content: "\EDC6"; }
.ms-Icon--OpenPaneMirrored:before { content: "\EA5B"; }
.ms-Icon--Robot:before { content: "\E99A"; }
.ms-Icon--OfficeChat:before { content: "\F70F"; }
.ms-Icon--WhiteBoardApp16:before { content: "\F673"; }
.ms-Icon--ArrowTallUpLeft:before { content: "\F2BD"; }
.ms-Icon--RectangleShape:before { content: "\F1A9"; }
.ms-Icon--Settings:before { content: "\E713"; }
.ms-Icon--Contact:before { content: "\E77B"; }
.ms-Icon--EraseTool:before { content: "\E75C"; }
.ms-Icon--ChromeClose:before { content: "\E8BB"; }
.ms-Icon--OpenPane:before { content: "\E8A0"; }


    </style>
    <style>
        /* 
            Style for the background. 
            
            Generate your custom css gradients at https://cssgradient.io/ 
        */
        body {
            font-family: monospace;
            overflow: hidden;
        }
        .container {
            padding-top: 56.25%;
            position: relative;
            width: 100%;            
        }

        footer {
            font-size: 70%;
            color: white;
            position: absolute;
            bottom: 0.5%;
            left: 1%;
            opacity: 90%;
            text-shadow: black 1px 1px;
        }

        footer>a {
            color: white;
            text-decoration: none;
        }

        /* 
            Style for the boxes.

            https://alligator.io/css/gradient-borders-pure-css/ 
        */
        .box {
            border: 0.5rem solid;
            border-radius: 0.5rem;

            transition: left 0.5s, right 0.5s, bottom 0.5s, top 0.5s, width 0.5s, height 0.5s, opacity 1s;
        }

        .hidden {
            display: none;
        }

        .rotate {
            transform: rotate(180deg);
            transform-origin: 50% 50%;
        }

        .ms-Icon {
            vertical-align: middle;
            margin-right: 0.2rem;
        }

        .item {
            cursor: pointer;
        }
        .error {
            border: solid 1px red;
            margin: 1rem 0rem 1rem 0rem;
            padding: 1rem;
            background: white;
        }
        #toolbox > button {
            height: 2rem;
            width: 2rem;
            border-radius: 1rem;
            background: black;
            color: white;
            padding: 0.47rem;
            margin: 0.25rem;
            cursor: pointer;
            opacity: 40%;
        }
        #toolbox > button:hover {
            opacity: 100%;
        }
        #toolbox > button.active {
            background: white;
            color: black;
        }
        #banner {
            margin: 0.5vh;
        }
        canvas {
            display: none;
        }
        .paint canvas {
            display: block;
            position:absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }
        .paint {
            cursor:pointer !important;
        }

        body.loading {
            filter: blur(0.2vw);
        }

        /*
        Settings
        */
        #settings {
            position: absolute;
            left: 16%;
            top: 16%;
            width: 58%;
            height: 58%;
            background: #ccc;
            padding: 5% 5% 5% 5%;
            overflow-y: auto;
        }

        #settings .field {
            padding: 1% 0 1% 0;
        }

        #settings .field input {
            width: 100%;
            font-size: 90%;
        }

        #settings .field input[type="checkbox"] {
            width: unset;
        }

        #settings .field select {
            width: 100%;
            font-size: 90%;
        }

        #settings #settingsclose {
            position: absolute;
            right: 2%;
            top: 2%;
        }

        /*
            MakeCode editor box
        */
        #editor {
            position: absolute;
            width: 94%;
            height: 87%;
            top: 1%;
            transition-delay: 0.2s;
        }

        .multi #editor {
            width: 50%;
        }

        #editor2 {
            position: absolute;
            width: 50%;
            height: 87%;
            top: 1%;
            transition-delay: 0.3s;
        }

        /*
            Face camera            
        */
        #facecam, #hardwarecam {
            position: absolute;
            width: 30%;
            bottom: 1.5%;
            right: 1%;
        }
        #hardwarecam {
            width: 0;
            right: -1rem;
            opacity: 0;
        }
        body.hardware #hardwarecam {
            opacity: 100%;
        }

        /*
            Chat window
        */
        #chat {
            position: absolute;
            width: 0;
            height: 60%;
            top: 1%;
            right: 1%;
            display: none;
            transition-delay: 0.3s;
        }

        #social {
            position: absolute;
            width: 60%;
            height: 5%;
            left: 1%;
            bottom: 2%;
            background: #615fc7;
            transition-delay: 0.1s;
        }
        #toolbox {
            float:right;
        }

        span.social {
            font-size: 2vh;
            color: white;
            flex-grow: 1;
            text-align: center;
            cursor: pointer;
        }
        video.error {
            background: rgba(255, 0, 0, 0.5)
        }

        /** 
        * chat visibility
        */
        body.chat #chat {
            display: block;
            opacity: 90%;
        }

        /* rightscene: browser with facecam on right */
        body.rightscene #editor {
            left: 1%;
        }

        body.rightscene #facecam {
            right: 1%;
            width: 28%;
        }
        
        body.rightscene #chat {
            right: 1%;
            width: 28%;
            height: 54%;
        }

        body.rightscene.chat #editor {
            width: 67%;
            top: 1%;
            height: 87%;
        }

        body.rightscene.hardware #hardwarecam {
            right: 1%;
            width: 22%;
            bottom: 42%;
        }

        body.rightscene.multi #editor {
            width: 67%;
        }

        body.rightscene.multi #editor2 {
            width: 28%;
            left: 70%;
            height: 54%;
        }
        body.rightscene.multi.hardware #hardwarecam {
            right: 1%;
            width: 22%;
            bottom: 24%;
        }

        /* leftscene: browser with facecam on left left */
        body.leftscene #editor {
            left: 4%;
            height: 87%;
        }

        body.leftscene #facecam {
            right: 70%;
            width: 28%;
        }

        body.leftscene #hardwarecam {
            bottom: 9%;
            right: 1%;
        }

        body.leftscene #social {
            width: 55%;
            height: 5%;
            left: 43%;
            bottom: 1.5%;
        }
        body.leftscene.hardware #hardwarecam {
            width: 22%;
        }

        /* left+multi*/
        body.leftscene.multi #editor {
            left: 1%;
            width: 28%;
            height: 54%;
        }

        body.leftscene.multi #editor2 {
            width: 67%;
            left: 31%;
        }

        body.leftscene.multi #facecam {
            right: 70%;
            width: 28%;
        }
        body.leftscene.multi.hardware #hardwarecam {
            right: 76%;
            width: 22%;
            bottom: 24%;
        }

        /** leftscene + chat **/
        body.leftscene.chat #editor {
            left: 31%;
            width: 67%;
        }

        body.leftscene.chat #facecam {
            right: 70%;
            width: 28%;
        }

        body.leftscene.chat #chat {
            right: 70%;
            height: 54%;
            width: 28%;
        }

        /* chatscene: facecam and stream chat */
        body.chatscene #facecam {
            bottom: 19%;
            right: 38%;
            width: 52%;
        }

        body.chatscene #editor {
            left: -150rem;
        }
        body.chatscene #editor2 {
            right: -150rem;
        }

        body.chatscene #chat {
            top: 9%;
            right: 4%;
            width: 24%;
            height: 80%;
            opacity: 100%;
        }

        body.chatscene #social {
            left: 4%;
            bottom: 9%;
        }

        body.chatscene.hardware #facecam {
            bottom: 19%;
            right: 49%;
            width: 46%;
        }
        body.chatscene.hardware #hardwarecam {
            width: 46%;
            bottom: 19%;
            right: 1%;            
        }
    </style>
    <style id="editorstyle"></style>
</head>

<body class="rightscene">
    <div id="container" class="container">
    <iframe class="box" id="editor" allow="usb;camera"></iframe>
    <iframe class="box" id="editor2" allow="usb;camera"></iframe>
    <iframe class="box" id="chat" sandbox="allow-scripts allow-same-origin"></iframe>
    <video class="box" autoplay="true" id="facecam"></video>
    <video class="box" autoplay="true" id="hardwarecam"></video>
    <canvas id="paint" class=""></canvas>
    <canvas id="painttool" class=""></canvas>
    <div class="box" id="social">
        <div id="toolbox">
        </div>
        <div id="banner"></div>
    </div>
    <div class="box hidden" id="settings">
        <button id="settingsclose">close</button>
        <h2>MakeCode Streamer settings</h2>
        <div class="field">
            <label for="editorselect">Choose your editor</label>
            <select id="editorselect"></select>
        </div>
        <div class="field">
            <input type="checkbox" id="multicheckbox"></input>
            <label for="multicheckbox">Multi editors</label>
        </div>
        <h2>Video</h2>
        <div class="field">
            <label for="facecamselect">Choose a Face Webcam</label>
            <select id="facecamselect"></select>
            <div class="error hidden" id="facecamerror">Connection error. Make sure the WebCam is not beging used by another application.</div>
        </div>
        <div class="field">
            <input type="checkbox" id="facerotatecameracheckbox"></input>
            <label for="facerotatecameracheckbox">Rotate camera 180</label>
        </div>
        <div class="field">
            <label for="hardwarecamselect">Choose a Hardware Webcam</label>
            <select id="hardwarecamselect"></select>
            <div class="error hidden" id="hardwarecamerror">Connection error. Make sure the WebCam is not beging used by another application.</div>
        </div>
        <div class="field">
            <input type="checkbox" id="hardwarerotatecameracheckbox"></input>
            <label for="hardwarerotatecameracheckbox">Rotate camera 180</label>
        </div>
        <h2>Social accounts</h2>
        <div class="field">
            <label for="twitterinput">Twitter (optional)</label>
            <input id="twitterinput" placeholder="Twitter handle (@account)" />
        </div>
        <div class="field">
            <label for="youtubeinput"">YouTube (optional)</label>
            <input id="youtubeinput" placeholder="YouTube account (/account)" />
        </div>
        <div class="field">
            <label for="mixerinput">Mixer (optional)</label>
            <input id="mixerinput" placeholder="Mixer.com account (/account)" />
        </div>
        <div class="field">
            <label for="twitchinput">Twitch (optional)</label>
            <input id="twitchinput" placeholder="Twitch.tv account (/account)" />
        </div>
    </div>
</div>
<footer>
    <a class="item" href="https://makecode.com/privacy" target="_blank" rel="noopener">Privacy &amp; Cookies</a>|
    <a class="item" href="https://makecode.com/termsofuse" target="_blank" rel="noopener">Terms Of Use</a>|
    <a class="item" href="https://makecode.com/trademarks" target="_blank" rel="noopener">Trademarks</a>|
    <span class="item">© 2020 Microsoft</span>
</footer>

    <!-- @include tracking.html -->
<script>
(async function () {
    const body = document.body;
    const container = document.getElementById("container");
    const editor = document.getElementById("editor");
    const editor2 = document.getElementById("editor2");
    const facecam = document.getElementById("facecam");
    const hardwarecam = document.getElementById("hardwarecam");
    const chat = document.getElementById("chat");
    const social = document.getElementById("social");
    const banner = document.getElementById("banner");
    const settings = document.getElementById("settings");
    const editorStyle = document.getElementById("editorstyle");
    const toolbox = document.getElementById("toolbox")
    const paint = document.getElementById('paint');
    const paintCtx = paint.getContext('2d');
    const painttool = document.getElementById('painttool');
    const painttoolCtx = painttool.getContext('2d');

    const frames = [editor, editor2];

    const scenes = ["leftscene", "rightscene", "chatscene"];
    const editorConfigs = await fetchJSON("/editors.json");
    const state = {
        sceneIndex: 1,
        left: false,
        chat: false,
        hardware: false,
        painttool: "arrow"
    }

    initMessages();
    loadPaint();
    await loadSettings()
    load();
    await loadFaceCam()
    await loadHardwareCam()
    tickEvent("streamer.load")

    function load() {
        loadEditor()
        loadChat()
        loadSocial()
        loadToolbox()
        render()
    }

    function saveConfig(config) {
        if (!config) throw "missing config"
        localStorage["streamer.config"] = JSON.stringify(config)
    }

    async function showSettings() {
        await loadSettings()
        settings.classList.remove("hidden")
    }

    function readConfig() {
        try {
            const cfg = JSON.parse(localStorage["streamer.config"]);
            if (cfg)
                return cfg;
        } catch (e) {
            console.log(e)
        }

        const cfg = {
            editor: "microbit",
            multiEditor: false,
            twitter: "",
            youTube: "",
            mixer: ""
        }
        saveConfig(cfg)
        return cfg;
    }

    async function fetchJSON(url) {
        const resp = await fetch(url)
        const json = await resp.json();
        return json;
    }

    function render() {
        const config = readConfig();
        body.className = `${scenes[state.sceneIndex]} ${state.hardware ? "hardware" : state.chat ? "chat" : ""} ${config.multiEditor ? "multi" : ""} ${state.paint ? "paint" : ""}`
        if (!config.faceCamId || state.faceCamError)
            showSettings();
    }

    function loadToolbox() {
        const config = readConfig();
        toolbox.innerHTML = ""

        if (state.paint) {
            addPaintButton("ArrowTallUpLeft", "Draw arrow", "arrow")
            addPaintButton("RectangleShape", "Draw rectangle", "rect")
            addPaintButton("PenWorkspace", "Draw freeform", "pen")
            addButton("WhiteBoardApp16", "Paint screen in white", whiteboard)
            addButton("EraseTool", "Clear all drawings", clearPaint)
            addButton("ChromeClose", "Exit paint mode", togglePaint)
        } else {
            addButton("OpenPane", "move webcam left", () => setScene("left"))
            addButton("OpenPaneMirrored", "move webcam right", () => setScene("right"))
            addButton("Contact", "webcam large", () => setScene("chat"))
            if (config.hardwareCamId)
            addButton("Robot", "hardware webcam", toggleHardware)
            if (config.mixer || config.twitch)
                addButton("OfficeChat", "show/hide chat", toggleChat)
            addButton("PenWorkspace", "Paint mode", togglePaint)
            addButton("Settings", "Show settings", showSettings);
        }

        function addButton(icon, title, handler) {
            const btn = document.createElement("button")
            btn.title = title
            btn.addEventListener("pointerdown", function(e) {
                tickEvent("streamer.button", { button: icon }, { interactiveConsent: true })
                handler(e)
            }, false)
            const i = document.createElement("i")
            btn.append(i)
            i.className = `ms-Icon ms-Icon--${icon}`
            toolbox.append(btn)
            return btn;
        }

        function addPaintButton(icon, title, tool) {
            const btn = addButton(icon, title, () => setPaintTool(tool));
            if (state.painttool == tool)
                btn.classList.add("active")
        }

        function setScene(scene) {
            tickEvent("streamer.scene", { scene: scene }, { interactiveConsent: true });
            state.sceneIndex = scenes.indexOf(`${scene}scene`);
            render();
        }
    }

    function togglePaint() {
        state.paint = !state.paint;
        clearPaint();
        updatePaintSize();
        loadToolbox();
        render();
    }

    function setPaintTool(tool) {
        state.painttool = tool;
        loadToolbox();
    }

    function whiteboard() {
        paintCtx.save()
        paintCtx.beginPath();
        paintCtx.fillStyle = "rgba(255, 255, 255, 0.9)"
        paintCtx.rect(0, 0, paint.width, paint.height)
        paintCtx.fill()
        paintCtx.restore()
    }

    function clearPaint() {
        paintCtx.clearRect(0,0,paint.width,paint.height);
        painttoolCtx.clearRect(0,0,paint.width,paint.height);
    }

    function updatePaintSize() {
        const size = container.getBoundingClientRect();
        paint.width = size.width;
        paint.height = size.height;
        painttool.width = size.width;
        painttool.height = size.height;
    }

    function loadPaint() {
        const mouse = {x: 0, y: 0};
        let head = {x:0,y:0}
        
        painttool.addEventListener('mousemove', function(e) {
            mouse.x = e.pageX - this.offsetLeft;
            mouse.y = e.pageY - this.offsetTop;
        }, false);
        
        painttool.addEventListener('mousedown', function(e) {
            head.x = e.pageX - this.offsetLeft;
            head.y = e.pageY - this.offsetTop;
            painttoolCtx.lineWidth = Math.max(10, (paint.width / 100) | 0);
            painttoolCtx.lineJoin = 'round';
            painttoolCtx.lineCap = 'round';
            painttoolCtx.strokeStyle = '#ffe135';
            if (state.painttool == 'pen') {
                painttoolCtx.beginPath();
                painttoolCtx.moveTo(mouse.x, mouse.y);
            }                
            painttool.addEventListener('mousemove', onPaint, false);
        }, false);
        
        painttool.addEventListener('mouseup', function() {
            paintCtx.drawImage(painttool, 0, 0)
            painttoolCtx.clearRect(0, 0, painttool.width, painttool.height)
            painttool.removeEventListener('mousemove', onPaint, false);
        }, false);
        
        function onPaint() {
            const ctx = painttoolCtx
            ctx.clearRect(0, 0, painttool.width, painttool.height)
            ctx.save();
            if (state.painttool == 'arrow') {

                const p1 = mouse, p2 = head;
                const size = ctx.lineWidth * 2;
                // Rotate the context to point along the path
                const dx = p2.x - p1.x
                const dy = p2.y - p1.y
                const len=Math.sqrt(dx*dx+dy*dy);
                ctx.translate(p2.x, p2.y);
                ctx.rotate(Math.atan2(dy,dx));

                // line
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(-len,0);
                ctx.closePath();
                ctx.stroke();

                // arrowhead
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(-size,-size);
                ctx.moveTo(0,0);
                ctx.lineTo(-size, size);
                ctx.stroke();
            } else if (state.painttool == 'rect') {
                ctx.beginPath();
                ctx.rect(head.x, head.y, mouse.x - head.x, mouse.y - head.y)
                ctx.stroke()
            } else if (state.painttool == 'pen') {
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
            }
            ctx.restore();
        }

        clearPaint();
    }

    function loadEditor() {
        const config = readConfig();
        // update first editor
        const editorConfig = editorConfigs[config.editor];
        if (!editorConfig) {
            showSettings();
            loadStyle();
            return;
        }

        let url = `${editorConfig.url}?editorLayout=ide&nosandbox=1`;
        if (config.multiEditor)
            url += `&nestededitorsim=1`;
        editor.src = url;
        if (config.multiEditor) {
            if (!editor2.parentElement)
                body.insertBefore(editor2, editor);
            editor2.src = url;
        } else {
            // remove from DOM
            editor2.remove();
        }

        // update page style
        let css = "";
        const styles = editorConfig.styles;
        if (styles) {
            css =
                `body {
background: ${styles.background};
}
.box {
border-color: ${styles.menu};
}
#social {
background: ${styles.primary};
}
`
        } else {
            css =
                `body {
background: rgb(99, 93, 198);
background: linear-gradient(45deg, rgba(99, 93, 198, 1) 0%, rgba(0, 212, 255, 1) 100%);
}
.box {
border-image: conic-gradient(red, yellow, lime, aqua, blue, magenta, red) 1;
}
#social {
background: #615fc7;
}
`
        }
        editorStyle.innerText = ""
        editorStyle.append(document.createTextNode(css));
    }

    function loadStyle() {
        const config = readConfig();
        const editorConfig = editorConfigs[config.editor];
        // update page style
        let css = "";
        const styles = editorConfig && editorConfig.styles;
        if (styles) {
            css =
                `body {
background: ${styles.background};
}
.box {
border-color: ${styles.menu};
}
#social {
background: ${styles.primary};
}
`
        } else {
            css =
                `body {
background: rgb(99, 93, 198);
background: linear-gradient(45deg, rgba(99, 93, 198, 1) 0%, rgba(0, 212, 255, 1) 100%);
}
.box {
border-image: conic-gradient(red, yellow, lime, aqua, blue, magenta, red) 1;
}
#social {
background: #615fc7;
}
`
        }
        editorStyle.innerText = ""
        editorStyle.append(document.createTextNode(css));
    }

    function stopEvent(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    function toggleChat(e) {
        tickEvent("streamer.togglechat", undefined, { interactiveConsent: true });
        stopEvent(e)
        const config = readConfig();
        state.chat = !state.chat && (config.mixer || config.twitch);
        render();
    }

    function toggleHardware(e) {
        tickEvent("streamer.togglehardware", undefined, { interactiveConsent: true });
        stopEvent(e)
        const config = readConfig();
        state.hardware = !state.hardware && config.hardwareCamId;
        render();
    }

    function loadSocial() {
        const config = readConfig();
        banner.innerHTML = ''
        if (config.twitter)
            addSocial(`@${config.twitter}`)
        if (config.youTube)
            addSocial(`youtube.com/${config.youTube}`);
        if (config.mixer)
            addSocial(`mixer.com/${config.mixer}`);
        else if (config.twitch)
            addSocial(`twitch.tv/${config.twitch}`);

        if (!config.mixer && !config.twitch)
            state.chat = false;

        function addSocial(text) {
            const a = document.createElement("span");
            a.className = "social"
            a.innerText = text
            banner.append(a)
        }
    }

    function loadChat() {
        const config = readConfig();
        if (config.mixer) {
            chat.src = `https://mixer.com/embed/chat/${config.mixer}?composer=false`;
            if (!chat.parentElement)
                body.insertBefore(chat, facecam)
        }
        else if (config.twitch) {
            chat.src = `https://www.twitch.tv/embed/${config.twitch}/chat?parent=makecode.com`;
            if (!chat.parentElement)
                body.insertBefore(chat, facecam)
        }
        else // remove from dom
            chat.remove();
    }

    async function listCameras() {
        let cams = await navigator.mediaDevices.enumerateDevices()
        cams = cams.filter(d => d.kind == "videoinput")
        return cams;
    }

    async function loadFaceCam() {
        // load previous webcam
        const config = readConfig();
        if (config.faceCamId) {
            try {
                state.faceCamError = false;
                body.classList.add("loading");
                facecam.classList.remove("error");
                await startStream(facecam, config.faceCamId, config.faceCamRotate);
                console.log(`face cam started`)
                return; // success!
            }
            catch (e) {
                stopStream(facecam);
                facecam.classList.add("error");
                state.faceCamError = true;
                saveConfig(config)
                console.log(`could not start face cam`, e)
                render()
            }
            finally  {
                body.classList.remove("loading");
            }
        } else {
            state.faceCamError = true;
            facecam.classList.add("error");
            stopStream(facecam);
        }
    }

    async function loadHardwareCam() {
        // load previous webcam
        const config = readConfig();
        if (config.hardwareCamId) {
            try {
                state.hardwareCamError = false;
                await startStream(hardwarecam, config.hardwareCamId, config.hardwareCamRotate);
                console.log(`hardware cam started`)
                return; // success!
            }
            catch (e) {
                stopStream(hardwarecam)
                state.hardwareCamError = true;
                saveConfig(config)
                console.log(`could not start web cam`, e)
                render()
            }
        } else {
            state.hardwareCamError = false
            stopStream(hardwarecam)
        }
    }


    function stopStream(el) {
        try {
            if (el.srcObject) {
                const tracks = el.srcObject.getVideoTracks();
                if (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();
            }
            el.srcObject = null;
        } catch (e) { }
    }

    function initMessages() {
        window.onmessage = function (msg) {
            const data = msg.data;
            const source = msg.source;
            if (!!data.broadcast) {
                data.outer = true;
                frames
                    .filter(ifrm => ifrm.contentWindow !== source)
                    .forEach((ifrm) => ifrm.contentWindow.postMessage(data, "*"));
            }
        };
    }

    async function startStream(el, deviceId, rotate) {
        stopStream(el)
        console.log(`trying webcam ${deviceId}`)
        const constraints = {
            audio: false,
            video: {
                deviceId: deviceId,
                aspectRatio: 4/3
            }
        }
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        el.volume = 0; // don't use sound!
        el.srcObject = stream;
        el.onloadedmetadata = (e) => el.play();
        if (rotate)
            el.classList.add("rotate")
        else
            el.classList.remove("rotate");
    }

    async function loadSettings() {
        const config = readConfig();
        const cams = await listCameras()

        const settingsclose = document.getElementById("settingsclose")
        settingsclose.onclick = function (e) {
            tickEvent("streamer.settingsclose", undefined, { interactiveConsent: true })
            stopEvent(e)
            settings.classList.add("hidden")
        }
        const editorselect = document.getElementById("editorselect");
        editorselect.innerHTML = "" // remove all web cams
        Object.keys(editorConfigs).forEach(editorid => {
            const option = document.createElement("option")
            option.value = editorid
            option.text = editorConfigs[editorid].name;
            editorselect.add(option)
            if (config.editor == editorid)
                option.selected = true;
        })
        editorselect.onchange = function () {
            const selected = editorselect.options[editorselect.selectedIndex];
            config.editor = selected.value;
            saveConfig(config);
            render()
            loadEditor();
        }

        const multicheckbox = document.getElementById("multicheckbox")
        multicheckbox.checked = !!config.multiEditor
        multicheckbox.onchange = function () {
            config.multiEditor = !!multicheckbox.checked
            saveConfig(config)
            render()
            loadEditor()
        }

        const facecamselect = document.getElementById("facecamselect");
        facecamselect.innerHTML = "" // remove all web cams
        cams.forEach(cam => {
            const option = document.createElement("option")
            option.value = cam.deviceId
            option.text = cam.label || `camera ${cam.deviceId}`
            facecamselect.add(option)
            if (!cam.label && !config.faceCamId) { // we haven't asked for videos yet
                config.faceCamId = cam.deviceId;
                saveConfig(config);
            }   
            if (config.faceCamId == cam.deviceId)
                option.selected = true;
        })
        facecamselect.onchange = function () {
            const selected = facecamselect.options[facecamselect.selectedIndex];
            config.faceCamId = selected.value;
            if (config.hardwareCamId == config.faceCamId)
                config.hardwareCamId = undefined; // priority to face cam
            saveConfig(config)
            loadFaceCam().then(() => loadSettings())
        }
        const facerotatecheckbox = document.getElementById("facerotatecameracheckbox")
        facerotatecheckbox.checked = !!config.faceCamRotate
        facerotatecheckbox.onchange = function () {
            config.faceCamRotate = !!facerotatecheckbox.checked
            saveConfig(config)
            loadFaceCam().then(() => loadSettings())
        }
        const facecamerror = document.getElementById("facecamerror")
        if (config.faceCamId && state.faceCamError)
            facecamerror.classList.remove("hidden")
        else
            facecamerror.classList.add("hidden")

        const hardwarecamselect = document.getElementById("hardwarecamselect");
        hardwarecamselect.innerHTML = "" // remove all web cams
        const option = document.createElement("option")
        option.value = ""
        option.text = "Off"
        hardwarecamselect.add(option)
        cams.forEach(cam => {
            const option = document.createElement("option")
            option.value = cam.deviceId
            option.text = cam.label || `camera ${cam.deviceId}`
            hardwarecamselect.add(option)
            if (config.hardwareCamId == cam.deviceId)
                option.selected = true;
        })
        hardwarecamselect.onchange = function () {
            const selected = hardwarecamselect.options[hardwarecamselect.selectedIndex];
            config.hardwareCamId = selected.value;
            saveConfig(config)
            state.hardware = !!config.hardwareCamId
            loadToolbox()
            render()
            loadHardwareCam().then(() => loadSettings())
        }
        const hardwarerotatecheckbox = document.getElementById("hardwarerotatecameracheckbox")
        hardwarerotatecheckbox.checked = !!config.hardwareCamRotate
        hardwarerotatecheckbox.onchange = function () {
            config.hardwareCamRotate = !!hardwarerotatecheckbox.checked
            saveConfig(config)
            loadHardwareCam().then(() => loadSettings())
        }
        const hardwarecamerror = document.getElementById("hardwarecamerror")
        if (config.hardwareCamId && state.hardwareCamError)
            hardwarecamerror.classList.remove("hidden")
        else
            hardwarecamerror.classList.add("hidden")

        const twitterinput = document.getElementById("twitterinput")
        twitterinput.value = config.twitter || ""
        twitterinput.onchange = function (e) {
            config.twitter = (twitterinput.value || "").replace(/^https:\/\/twitter.com\//, '').replace(/^@/, '').trim()
            twitterinput.value = config.twitter
            saveConfig(config);
            loadSocial()
            render()
        }

        const youtubeinput = document.getElementById("youtubeinput")
        youtubeinput.value = config.youTube || ""
        youtubeinput.onchange = function (e) {
            config.youTube = (youtubeinput.value || "").replace(/^https:\/\/youtube.com\//, '').replace(/^\//, '').trim()
            youtubeinput.value = config.youTube
            saveConfig(config);
            loadSocial();
            render()
        }

        const twitchinput = document.getElementById("twitchinput")
        twitchinput.value = config.twitch || ""
        twitchinput.onchange = function (e) {
            config.twitch = (twitchinput.value || "").replace(/^https:\/\/twitch.tv\//, '').replace(/^\//, '').trim()
            twitchinput.value = config.twitch
            saveConfig(config);
            loadSocial();
            loadToolbox()
            loadChat();
            render()
        }

        const mixerinput = document.getElementById("mixerinput")
        mixerinput.value = config.mixer || ""
        mixerinput.onchange = function (e) {
            config.mixer = (mixerinput.value || "").replace(/^https:\/\/mixer.com\//, '').replace(/^\//, '').trim()
            mixerinput.value = config.mixer
            saveConfig(config);
            loadSocial();
            loadToolbox()
            loadChat();
            render()
        }
    }

    function tickEvent(id, data, opts) {
        if (typeof pxt === "undefined" || !pxt.aiTrackException || !pxt.aiTrackEvent) return;
        if (opts && opts.interactiveConsent && typeof mscc !== "undefined" && !mscc.hasConsent()) {
            mscc.setConsent();
        }
        const config = readConfig();
        const props = {
            editor: config.editor,
        };
        const measures = {
            multiEditor: config.multiEditor ? 1 : 0,
            twitter: config.twitter ? 1 : 0,
            mixer: config.mixer ? 1 : 0,
            twitch: config.twitch ? 1 : 0
        };
        if (data)
            Object.keys(data).forEach(k => {
                if (typeof data[k] == "string") props[k] = data[k];
                else if (typeof data[k] == "number") measures[k] = data[k];
                else props[k] = JSON.stringify(data[k] || '');
            });
        pxt.aiTrackEvent(id, props, measures);
    }
})()
</script>
</body>

</html>